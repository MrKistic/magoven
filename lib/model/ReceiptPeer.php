<?php


/**
 * Skeleton subclass for performing query and update operations on the 'receipt' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Wed May 15 17:26:04 2013
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class ReceiptPeer extends BaseReceiptPeer {

  const TYPE_ISSUE = 'issue';
  const TYPE_AUTO_RENEWABLE = 'auto-renewable-subscription';
  const TYPE_FREE_SUBSCRIPTION = 'free-subscription';

  public static function retrieveUnique($app_id, $user_id, $transaction_id)
  {
    $c = new Criteria();
    $c->add(self::APPLICATION_ID, $app_id);
    $c->add(self::USER_ID, $user_id);
    $c->add(self::TRANSACTION_ID, $transaction_id);

    $v = self::doSelectOne($c);
    return $v;
  }

  /**
   * Validate InApp Purchase Receipt, by calling the Apple iTunes verifyReceipt method
   * Note that this seems to take between 2-4 seconds on average
   *
   * @param String $receipt_data
   * @param String $app_id
   * @param String $user_id
   * @param Publication $publication
   * @return Boolean
   */
  public static function verifyReceipt($receipt_data, $app_id, $user_id, $forceSandbox=NULL)
  {
    OvenLog::logInfo("Verifying receipt with Apple", $app_id, $user_id);

    $publication = PublicationPeer::retrieveByApplicationId($app_id);
    $sharedSecret = $publication->getItunesSharedSecret();

    if ($publication->isSandbox() || $forceSandbox) {
      $endpoint = SubscriptionPeer::ITUNES_URL_SANDBOX;
    }
    else {
      $endpoint = SubscriptionPeer::ITUNES_URL_PRODUCTION;
    }

    OvenLog::logInfo('Endpoint = ' . $endpoint, $app_id, $user_id);

    // If no shared secret exists, don't send it to the verifyReceipt call - but it should exist!
    if ($sharedSecret) {

      $postData = json_encode(array(
        'receipt-data' => $receipt_data,
        'password' => $sharedSecret
      ));

    } else {

      $postData = json_encode(array(
        'receipt-data' => $receipt_data
      ));

    }

    $ch = curl_init($endpoint);
    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_POST, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);
    $response = curl_exec($ch);
    $errno = curl_errno($ch);
    $errmsg = curl_error($ch);
    curl_close($ch);

    if ($errno != 0) {
      OvenLog::logError('verifyReceipt::Curl Error: ' . $errmsg . '; ' . $errno, $app_id, $user_id);
      throw new Exception($errmsg, $errno);
    }

    $data = json_decode($response);

    if (!is_object($data)) {
      OvenLog::logError('verifyReceipt::Invalid Response Data: '. $response, $app_id, $user_id);
      throw new Exception('Invalid Response Data');
    }

    OvenLog::logInfo("Receipt Data: Status = {$data->status}", $app_id, $user_id);
    OvenLog::logInfo(print_r($data, true), $app_id, $user_id);

    if (!isset($data->status) || ($data->status != 0 && $data->status != SubscriptionPeer::APPLE_STATUS_EXPIRED)) {
      $product_id = $data->receipt->product_id;
      OvenLog::logWarning('verifyReceipt::Invalid receipt: PRODUCT ID = ' . $product_id  . '; STATUS = ' . $data->status, $app_id, $user_id);
      throw new Exception('Invalid Receipt', $data->status);
    }

    return $data;

  }

} // ReceiptPeer
