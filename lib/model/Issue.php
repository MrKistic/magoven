<?php


/**
 * Skeleton subclass for representing a row from the 'issue' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Wed May 15 17:24:39 2013
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class Issue extends BaseIssue {

	/**
	 * Initializes internal state of Issue object.
	 * @see        parent::__construct()
	 */
	public function __construct()
	{
		// Make sure that parent constructor is always invoked, since that
		// is where any default values for this object are set.
		parent::__construct();
	}

  public function __toString()
  {
    return $this->getName();
  }

  private function recursiveRemoveDirectory($directory)
  {
    foreach(glob("{$directory}/*") as $file) {
      if(is_dir($file)) {
        recursiveRemoveDirectory($file);
      } else {
        unlink($file);
      }
    }
    rmdir($directory);
  }

  public function postInsert(PropelPDO $con = null)
  {
    // because the file generation methods don't actually have an ID until now, update the file name post insert
    if (file_exists($this->getHpub())) {
      rename($this->getHpub(), $this->getUploadedHpubPath($this->id . basename($this->getHpub())));
      $this->setUploadedHpub($this->id . $this->getUploadedHpub());
    }

    $coverImage = $this->getUploadedCoverPath($this->getUploadedCover());
    if (file_exists($coverImage)) {
      rename($coverImage, $this->getUploadedCoverPath($this->id . basename($this->getCoverImage())));
      $this->setUploadedCover($this->id . $this->getUploadedCover());
    }

    $this->doSave($con);
  }

  /**
   *
   * This is called after saving the Issue and saving any uploaded .hpub files.
   * This method allows you to make any modifications to the .hpub if required.
   *
   * @param PropelPDO $con
   */
  public function postSave(PropelPDO $con = null)
  {

    // For example, if there is a new .hpub file uploaded, modify book.json
    if ($this->newHpub && file_exists($this->getHpub())) {

      $za = new ZipArchive();
      $res = $za->open($this->getHpub());
      if ($res === TRUE) {

        // expand the .hpub into tmp dir
        $dir = $this->getUploadedHpubPath($this->id . '_tmp_dir');
        mkdir($dir);
        $za->extractTo($dir);

        // get book.json file
        $book = json_decode(file_get_contents($dir.'/book.json'), true);

        // add / modify properties
        $book['-baker-index-height'] = 240; // height is fixed
        $iWidth = (count($book['contents']) * 160) + 75;  // width is number of pages * 160px + 75px right margin
        if ($iWidth < 768) {  // minimum width of screen
          $iWidth = 768;
        }
        $book['-baker-index-width'] = $iWidth;
        $book['zoomable'] = false;  // no bloody zoom!

        // write book.json back out
        file_put_contents($dir.'/book.json', json_encode($book));

        // replace in archive & save as .hpub again
        $za->addFile($dir.'/book.json', 'book.json');
        $za->close();

        // trash tmp dir
        $this->recursiveRemoveDirectory($dir);

      } // if ziparchive

    } // done

  } // postSave

  public function preSave(PropelPDO $con = null)
  {
    // @todo: Remove product id if free - why?
    // if ($this->getFree()) {
    //  $this->setProductId(NULL);
    // }

    $this->newHpub = $this->isColumnModified(IssuePeer::UPLOADED_HPUB);

    $this->setItunesUpdated(time());
    $this->getPublication()->setItunesUpdated(time());

    if ($this->published && $this->itunes_include && !$this->itunes_published) {
      // if we're published and we're including in iTunes fee, make sure we have an iTunes published date too
      $this->setItunesPublished(time());
    }

    return true;
  }

  /**
   * Check download status for a given Issue. Always returns TRUE if the issue is free, or otherwise check
   * for the purchased status of this Issue for the given User ID.
   *
   * @param $app_id Application ID i.e. Publication::ApplicationID
   * @param $user_id User ID sent from device
   *
   * @return boolean
   */
  public function canDownload($app_id, $user_id)
  {

    if ($this->getFree()) {

      return TRUE;

    } else {

      // check Purchases
      return PurchasePeer::isPurchased($app_id, $user_id, $this->getProductId());

    }

  }

  /**
   * Can you send a notification for this Issue?
   * Conditions are:
   *   - allow notifications
   *   - is published
   *   - notification not already sent
   *   - issue is Free
   *
   *   - @todo: we should also send them for issues which are paid and the device has a valid subscription
   *
   * @return bool
   */
  public function canNotify()
  {
    return $this->getAllowNotification() && $this->getPublished() && $this->getFree() && !$this->getNotified();
  }

  public function ignoreApns()
  {
    $this->setAllowNotification(false);
    $this->save();
  }

  public function createApnsNotifications()
  {
    $pub = $this->getPublication();

    $apns = new OvenAPNS($pub->getApplicationId());
    $devices = $pub->getApnsDevices();

    /** @var ApnsDevice $device */
    foreach ($devices as $device) {
      $apns->newMessage($device->getPid());
      $apns->addMessageCustom('aps', array('content-available' => 1));
      $apns->addMessageCustom('content-name', $this->getName());
      $apns->queueMessage();
    }

    $this->setNotified(true);
    $this->save();

    return count($devices);
  }

  public function generateUploadedCoverFileName($file)
  {
    if ($file->getOriginalName()) {
      $filename = preg_replace('/\s+/', '_', $file->getOriginalName());
      return $this->id . '_cover_' . $filename;
    } else {
      return '';
    }
  }

  public function generateUploadedHpubFileName($file)
  {
    if ($file->getOriginalName()) {
      $filename = preg_replace('/\s+/', '_', $file->getOriginalName());
      return $this->id . '_hpub_' . $filename;
    } else {
      return '';
    }
  }

  public function generateUploadedZipFileName($file)
  {
    if ($file->getOriginalName()) {
      $filename = preg_replace('/\s+/', '_', $file->getOriginalName());
      return $this->id . '_zip_' . $filename;
    } else {
      return '';
    }
  }

  public function getUploadedCoverUrl($fileName)
  {
    $host = sfContext::getInstance()->getRequest()->getHost();
    // @todo: relying on the uploads folder not being changed - either force the path or work it out somehow
    return 'http://' . $host . '/uploads/' . $fileName;
  }

  public function getUploadedCoverPath($fileName)
  {
    $dir = sfConfig::get('sf_upload_dir');
//    return $dir . DIRECTORY_SEPARATOR . $this->id . '_cover_' . $fileName;
    return $dir . DIRECTORY_SEPARATOR . $fileName;
  }

  public function deleteExistingUploadedCover()
  {
    // remove existing file
    if ($this->getUploadedCover()) {
      $filePath = $this->getUploadedCoverPath($this->getUploadedCover());
      file_exists($filePath) && is_file($filePath) && unlink($filePath);
    }
  }

  public function getUploadedHpubUrl($fileName)
  {
    $host = sfContext::getInstance()->getRequest()->getHost();
    // @todo: relying on the uploads folder not being changed - either force the path or work it out somehow
    return 'http://' . $host . '/uploads/' . $fileName;
  }

  public function getUploadedHpubPath($fileName)
  {
    $dir = sfConfig::get('sf_upload_dir');
//    return $dir . DIRECTORY_SEPARATOR . $this->id . '_hpub_' . $fileName;
    return $dir . DIRECTORY_SEPARATOR . $fileName;
  }

  public function deleteExistingUploadedHpub()
  {
    // remove existing file
    if ($this->getUploadedHpub()) {
      $filePath = $this->getUploadedHpubPath($this->getUploadedHpub());
      file_exists($filePath) && is_file($filePath) && unlink($filePath);
    }
  }

  public function deleteExistingUploadedZip()
  {
    // remove existing file
    $filePath = $this->getUploadedHpubPath($this->getUploadedZip());
    file_exists($filePath) && unlink($filePath);
    // remove generated hpub file
    $filePath = $this->getUploadedHpubPath($this->id . '_' . IssuePeer::ZIP_HPUB_FILENAME);
    file_exists($filePath) && unlink($filePath);
  }

  function validateUploadType($validator, $values)
  {
    $errorSchema = new sfValidatorErrorSchema($validator);

    if ($values['upload_type'] == IssuePeer::UPLOAD_TYPE_URL) {

      // check the URL fields now
      if (empty($values['url'])) {
        $error = new sfValidatorError($validator, 'Required field');
        $errorSchema->addError($error, 'url');
      }
      if (empty($values['cover'])) {
        $error = new sfValidatorError($validator, 'Required field');
        $errorSchema->addError($error, 'cover');
      }

    } else if ($values['upload_type'] == IssuePeer::UPLOAD_TYPE_HPUB) {

      if (empty($values['uploaded_cover']) && !$this->getUploadedCover()) {
        $error = new sfValidatorError($validator, 'Required field');
        $errorSchema->addError($error, 'uploaded_cover');
      }
      if (empty($values['uploaded_hpub']) && !$this->getUploadedHpub()) {
        $error = new sfValidatorError($validator, 'Required field');
        $errorSchema->addError($error, 'uploaded_hpub');
      }

    } else if ($values['upload_type'] == IssuePeer::UPLOAD_TYPE_ZIP) {

      if (empty($values['uploaded_zip']) && !$this->getUploadedZip()) {
        $error = new sfValidatorError($validator, 'Required field');
        $errorSchema->addError($error, 'uploaded_zip');
      }
      if (empty($values['uploaded_cover']) && !$this->getUploadedCover()) {
        $error = new sfValidatorError($validator, 'Required field');
        $errorSchema->addError($error, 'uploaded_cover');
      }

      if (isset($values['uploaded_zip'])) {
        /** @var sfValidatedFile $zip */
        $zip = $values['uploaded_zip'];
        if ($zip->getType() != 'application/zip') {
          $error = new sfValidatorError($validator, 'You must upload a .zip file');
          $errorSchema->addError($error, 'uploaded_zip');
        }
      }

    }

    if (count($errorSchema)) {
      throw new sfValidatorErrorSchema($validator, $errorSchema);
    }

    // password is correct, return the clean values
    return $values;
  }

  function getCoverImage()
  {
    if ($this->getUploadType() == IssuePeer::UPLOAD_TYPE_URL) {
      return $this->getCover();
    } else {
      return $this->getUploadedCoverUrl($this->getUploadedCover());
    }

  }

  function getHpub()
  {
    if ($this->getUploadType() == IssuePeer::UPLOAD_TYPE_URL) {
      return $this->getHpub();
    } else if ($this->getUploadType() == IssuePeer::UPLOAD_TYPE_HPUB) {
      return $this->getUploadedHpubPath($this->getUploadedHpub());
    } else {
      return $this->getUploadedHpubPath($this->id . '_' . IssuePeer::ZIP_HPUB_FILENAME);
    }
  }

  public function getItunesDate($fmt)
  {
    if ($this->getItunesPublished()) {
      return $this->getItunesPublished($fmt);
    } else {
      return $this->getDate($fmt);
    }
  }

  public function getItunesImageUrl()
  {
    if ($this->getItunesCoverartUrl()) {
      return $this->getItunesCoverartUrl();
    } else {
      return $this->getCoverImage();
    }
  }

  public function getUrlForShelf()
  {
    if ($this->getUploadType() == IssuePeer::UPLOAD_TYPE_HPUB) {
      return $this->getUploadedHpubUrl($this->getUploadedHpub());
    } else {
      return $this->getUrl();
    }
  }

  public function getCoverForShelf()
  {
    if ($this->getUploadType() == IssuePeer::UPLOAD_TYPE_HPUB) {
      return $this->getUploadedCoverUrl($this->getUploadedCover());
    } else {
      return $this->getCover();
    }
  }

} // Issue
